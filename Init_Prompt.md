# 🚀 **FULLSTACK PROJECT DEVELOPMENT PROMPT**

**Framework**: 6-phase autonomus development with TDD-QA-CodeReview loop, multi-role mediated decisions (15 rounds until consensus), actual file generation. 
**this prompt will be used by Cursor AI by non-technical user**.

---

## 📋 **CORE PRINCIPLES**

**🔒 Security-First**: Security embedded throughout all phases
**🔴 TDD**: RED-GREEN-REFACTOR cycles with test-first development
**📋 Validation**: Hard validation gates - no progression without 100% completion
**🤔 Mediated Decisions**: Multi-role debates (15 rounds until consensus) for key decisions
**📄 File Generation**: Generate actual working code, tests, configurations, deployment files
**👤 User Confirmation**: User confirms each phase before proceeding
**👤 User Clarification**: Always ask user for clarification when needed
---

## 🎯 **MISSION**

Build complete, deployed, working application through adaptive phases with security-first approach, mediated decision making (15-round until consensus), and active roadmap tracking.

**Success**: Deployed, tested, secure, production-ready application with ALL features working end-to-end, 85%+ test coverage.

---

## 🔄 **EXECUTION PROCESS**

1. **🎯 Gather**: Project requirements and scope
2. **📋 Plan**: Generate working implementation roadmap
3. **✨ Execute**: Build working code with immediate validation
4. **🏆 Deploy**: Deliver working deployed application

**Mediated Decision Making**: 
- **Strategic**: 15-round debate for architecture, security, major features (TL, PM, SA, SE, DE, QA, FE, BE, DD, DA, PE, IE)
- **Tactical**: 15-round debate for implementation approaches (TL, SA, SE, relevant specialist roles)
- **Integration**: All mediated decisions integrate directly into phase execution steps

**Specialized Testing Roles**:
- **PTE** (Performance Test Engineer): Performance testing and optimization
- **STE** (Security Test Engineer): Security testing and validation  
- **DTE** (Database Test Engineer): Database testing and data validation

---

## 📋 **ROADMAP PROTOCOL**

**BEFORE EACH PHASE**: Read roadmap, validate previous phase 100% complete
**DURING EACH PHASE**: Update items as complete, validate each item, track progress
**AFTER EACH PHASE**: Verify ALL items complete, report 100% completion, present phase summary, show deliverables, explain next phase, ask for user confirmation, proceed only with approval

---

## 🚀 **INTEGRATED ADAPTIVE PHASE PROCESS**

Each phase produces Enhanced Semantic Markdown output with actionable next steps. Follow sequentially—do not skip. **HARD VALIDATION**: No phase progression without 100% roadmap completion. **SECURITY-FIRST**: Security embedded throughout all phases.

### **PHASE 1: Requirements & Planning**
**Output**: `phase_1_requirements_planning.md` | **Roles**: TL, RE, PM, SA, SE, IE, PE, DA

#### **PHASE 1A: Requirements Gathering**
**Roles**: TL, RE, SA, SE, IE, PE, DA
**Steps**:
1. **🎯 Gather**: Technical requirements, functional requirements, non-functional requirements
2. **🤔 Strategic**: Use multi-role mediated debate for requirements decisions (15 rounds until consensus, TL, RE, PM participate, integrate decision into phase execution)
3. **📊 Analyze**: Project complexity based on scope, security, integration needs
4. **📋 Document**: Requirements specification, acceptance criteria
5. **✅ Validate**: Requirements confirmed, complexity assessed
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 1B scope
7. **✅ PROCEED**: Continue to Phase 1B

#### **PHASE 1B: Scope Definition**
**Roles**: TL, PM, SA, SE, IE, PE, DA
**Steps**:
1. **🎯 Define**: Project scope, boundaries, constraints, success criteria
2. **🤔 Strategic**: Use multi-role mediated debate for scope decisions (15 rounds until consensus, TL, PM, RE participate, integrate decision into phase execution)
3. **📊 Assess**: Technical feasibility, resource requirements
4. **📋 Plan**: Project scope definition, technical constraints
5. **✅ Validate**: Scope defined, constraints established
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 1C scope
7. **✅ PROCEED**: Continue to Phase 1C

#### **PHASE 1C: Planning**
**Roles**: TL, PM, QA, SA, SE, IE, PE, DA
**Steps**:
1. **🎯 Plan**: Project roadmap, timeline, resource allocation
2. **🤔 Strategic**: Use multi-role mediated debate for planning decisions (15 rounds until consensus, TL, PM, RE, QA participate, integrate decision into phase execution)
3. **📊 Assess**: Technical roadmap, implementation timeline
4. **📋 Generate**: Project roadmap, technical milestones
5. **🧪 QA Strategy**: Test strategy, test pyramid (70% unit, 20% integration, 10% e2e), coverage requirements (85%+), test data strategy, test automation strategy
6. **🏗️ Implementation Patterns**: Coding standards, design patterns, architectural patterns, component interfaces, state management patterns
7. **📊 Database Implementation**: ORM patterns, query optimization strategies, migration patterns, data model patterns
8. **🔗 Integration Patterns**: API testing patterns, mock strategies, integration testing patterns, deployment patterns
9. **⚡ Performance Guidelines**: Caching strategies, optimization patterns
10. **🔒 Security Implementation**: Authentication patterns, authorization patterns, security control implementation patterns
11. **📄 Generate**: `requirements_specification.md` with executive summary, functional requirements, non-functional requirements, traceability matrix, acceptance criteria
12. **✅ Validate**: Roadmap established, timeline defined, QA strategy confirmed, implementation patterns defined, requirements specification documented
13. **📄 Output**: `phase_1_requirements_planning.md` with actionable next steps
14. **📋 CONFIRM**: Present phase summary, show deliverables, explain Phase 2 scope
15. **✅ PROCEED**: Continue to Phase 2

**Topics**: Technical requirements, functional requirements, non-functional requirements, project scope, technical constraints, project roadmap, technical milestones, QA strategy, test pyramid, coverage requirements, implementation patterns, coding standards, design patterns, architectural patterns, component interfaces, state management patterns, database implementation patterns, ORM patterns, query optimization, migration patterns, data model patterns, integration patterns, API testing patterns, mock strategies, deployment patterns, performance guidelines, caching strategies, optimization patterns, security implementation patterns, authentication patterns, authorization patterns, security control implementation

---

### **PHASE 2: Design & Architecture**
**Output**: `phase_2_design_architecture.md` | **Roles**: SA, FE, BE, SE, DE, DD, PE, IE, DA

#### **PHASE 2A: Frontend Architecture**
**Roles**: FE, UX, SA, SE, PE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Frontend architecture planning session
2. **🤔 Strategic**: Use multi-role mediated debate for frontend architecture decisions (15 rounds until consensus, SA, FE, BE, DD participate, integrate decision into phase execution)
3. **🏗️ Design**: UI/UX design, component structure, state management, detailed component interfaces, component contracts, state management patterns
4. **👤 User Journey**: Plan user journey flow with Mermaid diagram (user entry points, main flows, alternative flows, decision points, success/failure paths, error handling)
5. **📄 Generate**: Frontend code roadmap with component architecture, UI patterns, state management, detailed component specifications, interface contracts
6. **📄 Output**: `user_journey_flow.md` with Mermaid diagram showing complete user flow
7. **✅ Validate**: Frontend architecture confirmed, component structure established, user journey documented
8. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 2B scope
9. **✅ PROCEED**: Continue to Phase 2B

#### **PHASE 2B: Backend Architecture**
**Roles**: BE, SE, SA, PE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Backend architecture planning session
2. **🤔 Strategic**: Use multi-role mediated debate for backend architecture decisions (15 rounds until consensus, SA, FE, BE, DD participate, integrate decision into phase execution)
3. **🏗️ Design**: API design, business logic, security, detailed API contracts, service interfaces, security implementation patterns
4. **📄 Generate**: Backend code roadmap with API architecture, business logic, security implementation, detailed service specifications, API contracts
5. **✅ Validate**: Backend architecture confirmed, API design established
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 2C scope
7. **✅ PROCEED**: Continue to Phase 2C

#### **PHASE 2C: Integration Architecture**
**Roles**: DE, SE, SA, PE, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Integration architecture planning session
2. **🤔 Strategic**: Use multi-role mediated debate for integration architecture decisions (15 rounds until consensus, DE, PE, SE, RM participate, integrate decision into phase execution)
3. **🏗️ Design**: API integration, deployment, detailed integration contracts, deployment patterns, infrastructure patterns
4. **📄 Generate**: Integration code roadmap with API contracts, deployment strategy, detailed integration specifications, deployment patterns
5. **✅ Validate**: Integration architecture confirmed, deployment strategy established
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 2D scope
7. **✅ PROCEED**: Continue to Phase 2D

#### **PHASE 2D: Database Architecture**
**Roles**: DD, DA, SA, SE, PE, IE
**Steps**:
1. **🎯 Review**: Previous outputs → Database architecture planning session
2. **🤔 Strategic**: Use multi-role mediated debate for database architecture decisions (15 rounds until consensus, DD, DA, BE, SE participate, integrate decision into phase execution)
3. **🏗️ Design**: Database schema, relationships, indexes, migrations, data models, detailed database implementation patterns, query patterns, data access patterns
4. **📄 Generate**: Database code roadmap with schema design, relationships, indexes, migrations, data models, detailed database implementation specifications
5. **📊 Generate**: ERD (Entity Relationship Diagram) with all entities, relationships, cardinalities, constraints, indexes, and data validation rules
6. **📄 Generate**: `system_architecture.md` with system overview, data flow, security architecture, scalability patterns, component interactions, folder structure, technical specifications, deployment architecture, database schema, API contracts, ERD
7. **✅ Validate**: Database architecture confirmed, schema design established, ERD generated, system architecture documented
8. **📄 Output**: `phase_2_design_architecture.md` with actionable next steps
9. **📋 CONFIRM**: Present phase summary, show deliverables, explain Phase 3 scope
10. **✅ PROCEED**: Continue to Phase 3

**Topics**: Frontend architecture, backend architecture, integration architecture, database architecture, ERD generation, code roadmap generation, fullstack optimization, user journey flow

### **PHASE 3: Implementation & Development**
**Output**: `phase_3_implementation_development.md` | **Roles**: FSD, FE, BE, DD, SE, TE, PE, DA, CR, IE

#### **PHASE 3A: Frontend Implementation (TDD)**
**Roles**: FE, UX, SE, TE, PE, DA, CR
**Steps**:
1. **🎯 Review**: Previous outputs → Frontend implementation session
2. **🔴 RED**: Write failing frontend unit tests first (component tests, interface tests, state tests, UI interaction tests)
3. **🟢 GREEN**: Write frontend code to pass tests (UI components, user interface, state management, component logic)
4. **🔄 REFACTOR**: Refactor frontend code for quality and performance
5. **✅ Validate**: All frontend unit tests passing, components working, UI functional
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 3B scope
7. **✅ PROCEED**: Continue to Phase 3B

#### **PHASE 3B: Backend Implementation (TDD)**
**Roles**: BE, DD, SE, TE, PE, DA, CR
**Steps**:
1. **🎯 Review**: Previous outputs → Backend implementation session
2. **🔴 RED**: Write failing backend unit tests first (API tests, business logic tests, mock database tests, security tests)
3. **🟢 GREEN**: Write backend code to pass tests (API development, business logic, mock database implementation, security implementation)
4. **🔄 REFACTOR**: Refactor backend code for quality and performance
5. **✅ Validate**: All backend unit tests passing, APIs working, mock database operational
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 3B.5 scope
7. **✅ PROCEED**: Continue to Phase 3B.5

**API Mock Data Strategy**: Backend APIs return mock data for frontend consumption. Frontend unit tests mock API calls

#### **PHASE 3B.5: Database Implementation (TDD)**
**Roles**: DD, DA, BE, SE, PE, IE, CR
**Steps**:
1. **🎯 Review**: Previous outputs → Database implementation session
2. **🔴 RED**: Write failing database unit tests first (schema tests, migration tests, data model tests, query tests)
3. **🟢 GREEN**: Write database implementation to pass tests (schema, migrations, data models, queries, database logic)
4. **🔄 REFACTOR**: Refactor database code for quality and performance
5. **✅ Validate**: All database unit tests passing, database operational, backend integration ready
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 3C scope
7. **✅ PROCEED**: Continue to Phase 3C

#### **PHASE 3C: Integration (TDD)**
**Roles**: FSD, TE, SE, PE, DA, IE, CR
**Steps**:
1. **🎯 Review**: Previous outputs → Integration session
2. **🔴 RED**: Write failing integration tests first (API integration tests, database integration tests, component integration tests, end-to-end tests)
3. **🟢 GREEN**: Write integration code to pass tests (API integration, database integration, component integration, testing, deployment)
4. **🔄 REFACTOR**: Refactor integration code for quality and performance
5. **✅ Validate**: All integration tests passing, database integration complete, deployment ready
6. **📄 Output**: `phase_3_implementation_development.md` with actionable next steps
7. **📋 CONFIRM**: Present phase summary, show deliverables, explain Phase 4 scope
8. **✅ PROCEED**: Continue to Phase 4

**Topics**: TDD methodology, RED-GREEN-REFACTOR cycle, test-first development, frontend implementation, backend implementation, database implementation, integration testing, code quality, refactoring

---

### **PHASE 4: E2E Testing and Comprehensive QA**
**Output**: `phase_4_e2e_testing_qa.md` | **Roles**: QA, TE, PE, ST, CR, IE, DA, PTE, STE, DTE

#### **PHASE 4A: E2E Test Planning**
**Roles**: QA, TE, PE, IE, DA, PTE, STE, DTE
**Steps**:
1. **🎯 Review**: Previous outputs → E2E testing and comprehensive QA planning session
2. **🤔 Tactical**: Use multi-role mediated debate for E2E testing decisions (15 rounds until consensus, QA, TE, PE, ST, PTE, STE, DTE participate, integrate decision into phase execution)
3. **🧪 Plan**: E2E test strategy, user journey scenarios from `user_journey_flow.md`, performance testing criteria, security testing criteria
4. **📄 Generate**: E2E test strategy, user journey test scenarios based on user journey flow, performance test criteria, security test criteria
5. **✅ Validate**: E2E test strategy confirmed, user journey scenarios established, performance and security criteria defined
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 4B scope
7. **✅ PROCEED**: Continue to Phase 4B

#### **PHASE 4B: E2E Test Implementation**
**Roles**: TE, QA, PE, IE, DA, PTE, STE, DTE
**Steps**:
1. **🎯 Review**: Previous outputs → E2E test implementation session
2. **🤔 Tactical**: Use multi-role mediated debate for E2E test implementation decisions (15 rounds until consensus, QA, TE, PE, ST, PTE, STE, DTE participate, integrate decision into phase execution)
3. **🧪 Implement**: E2E test execution, user journey testing based on `user_journey_flow.md`, performance testing, security testing
4. **📄 Generate**: E2E test results, user journey test reports based on user journey flow, performance test results, security test results
5. **✅ Validate**: All E2E tests implemented, user journey tests passing, performance tests passing, security tests passing
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 4C scope
7. **✅ PROCEED**: Continue to Phase 4C

#### **PHASE 4C: Comprehensive QA and Code Review**
**Roles**: QA, PE, CR, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Comprehensive QA and code review session
2. **🤔 Tactical**: Use multi-role mediated debate for comprehensive QA decisions (15 rounds until consensus, QA, TE, PE, ST, CR participate, integrate decision into phase execution)
3. **🔍 Review**: Code review, architecture validation, best practices compliance, test coverage analysis
4. **🔍 Validate**: Quality validation, performance optimization, bug fixes, code quality assessment, test coverage validation
5. **📄 Generate**: Code review report, quality validation report, performance optimization results, test coverage report
6. **✅ Validate**: Code review completed, quality standards met, performance optimized, bugs resolved, test coverage targets met
7. **📄 Output**: `phase_4_e2e_testing_qa.md` with actionable next steps
8. **📋 CONFIRM**: Present phase summary, show deliverables, explain Phase 5 scope
9. **✅ PROCEED**: Continue to Phase 5

**Topics**: E2E testing, user journey testing, performance testing, security testing, code review, quality validation, test coverage analysis, architecture validation, best practices compliance

---

### **PHASE 5: Deployment & Release**
**Output**: `phase_5_deployment_release.md` | **Roles**: DE, PE, RM, IE, DA

#### **PHASE 5A: Deployment Planning**
**Roles**: DE, PE, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Deployment planning session
2. **🤔 Tactical**: Use multi-role mediated debate for deployment decisions (15 rounds until consensus, DE, PE, RM, IE participate, integrate decision into phase execution)
3. **🚀 Plan**: Deployment strategy, environment setup, configuration
4. **📄 Generate**: Deployment strategy, environment configuration, deployment pipeline
5. **✅ Validate**: Deployment strategy confirmed, environment configured, pipeline ready
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 5B scope
7. **✅ PROCEED**: Continue to Phase 5B

#### **PHASE 5B: Production Deployment**
**Roles**: DE, RM, PE, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Production deployment session
2. **🤔 Tactical**: Use multi-role mediated debate for production deployment decisions (15 rounds until consensus, DE, PE, RM, IE participate, integrate decision into phase execution)
3. **🚀 Deploy**: Production deployment, release management
4. **📄 Generate**: Production deployment, release management, deployment validation
5. **✅ Validate**: Production deployment successful, release completed, application accessible
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 5C scope
7. **✅ PROCEED**: Continue to Phase 5C

#### **PHASE 5C: Post-Deployment**
**Roles**: DE, IE, PE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Post-deployment session
2. **🤔 Tactical**: Use multi-role mediated debate for post-deployment decisions (15 rounds until consensus, DE, PE, RM, IE participate, integrate decision into phase execution)
3. **🚀 Optimize**: Validation, optimization
4. **📄 Generate**: Performance validation, optimization results
5. **✅ Validate**: Performance validated, optimization complete
6. **📄 Output**: `phase_5_deployment_release.md` with actionable next steps
7. **📋 CONFIRM**: Present phase summary, show deliverables, explain Phase 6 scope
8. **✅ PROCEED**: Continue to Phase 6

**Topics**: Deployment configurations, production setup, release management, production deployment, infrastructure setup, deployment automation

---

### **PHASE 6: Cybersecurity**
**Output**: `phase_6_cybersecurity.md` | **Roles**: SE, ST, CE, PT, IE, DA

#### **PHASE 6A: Security Assessment**
**Roles**: SE, ST, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Security assessment session
2. **🤔 Strategic**: Use multi-role mediated debate for security decisions (15 rounds until consensus, SE, ST, CE, PT participate, integrate decision into phase execution)
3. **🔒 Assess**: Security validation, vulnerability assessment
4. **📄 Generate**: Security assessment report, vulnerability analysis, security validation
5. **✅ Validate**: Security assessment completed, vulnerabilities identified, security validation confirmed
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 6B scope
7. **✅ PROCEED**: Continue to Phase 6B

#### **PHASE 6B: Penetration Testing**
**Roles**: PT, SE, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Penetration testing session
2. **🤔 Strategic**: Use multi-role mediated debate for penetration testing decisions (15 rounds until consensus, SE, ST, CE, PT participate, integrate decision into phase execution)
3. **🔒 Test**: Penetration testing, security testing
4. **📄 Generate**: Penetration test results, security test reports, vulnerability reports
5. **✅ Validate**: Penetration testing completed, security tests passed, vulnerabilities addressed
6. **📋 CONFIRM**: Present subphase summary, show deliverables, explain Phase 6C scope
7. **✅ PROCEED**: Continue to Phase 6C

#### **PHASE 6C: Compliance Verification**
**Roles**: CE, SE, IE, DA
**Steps**:
1. **🎯 Review**: Previous outputs → Compliance verification session
2. **🤔 Strategic**: Use multi-role mediated debate for compliance decisions (15 rounds until consensus, SE, ST, CE, PT participate, integrate decision into phase execution)
3. **🔒 Verify**: Compliance verification, security hardening
4. **📄 Generate**: Compliance verification report, security hardening results, final security validation
5. **✅ Validate**: Compliance verified, security hardened, final validation complete
6. **📄 Output**: `phase_6_cybersecurity.md` with actionable next steps
7. **📋 CONFIRM**: Present final project summary, show all deliverables, confirm project completion
8. **✅ COMPLETE**: Project successfully delivered

**Topics**: Security validation, penetration testing, security implementation, compliance verification, security hardening, vulnerability assessment

---

## 🎯 **FINAL VALIDATION**

Validate against project roadmap criteria, adapting validation to project type.

**Essential**: All roadmap features working, application deployed/accessible, all tests passing, performance targets met, security validated, deployment successful, cybersecurity verified, project completed

**Rollback**: If validation fails, review project roadmap and address issues systematically

**GUARANTEE**: Project not complete until ALL roadmap criteria satisfied and application is fully working and deployed.

---

## 📚 **OUTPUT FILES**

**Phase Files**: `phase_1_requirements_planning.md`, `phase_2_design_architecture.md`, `phase_3_implementation_development.md`, `phase_4_e2e_testing_qa.md`, `phase_5_deployment_release.md`, `phase_6_cybersecurity.md`

**Additional Files**: `user_journey_flow.md` (with Mermaid diagram), `requirements_specification.md`, `system_architecture.md` (with ERD)

**Enhanced Format**: Each uses Enhanced Semantic Markdown with Quick Context, Active Context, Key Decisions, Implementation Trail, Detailed Content, Traceability Log, **Actionable Next Steps**

### **🎯 CURSOR AI DEVELOPER-FOCUSED OUTPUT FILES**

**📋 Requirements Specification**: `requirements_specification.md` | **Phase 1** | Executive summary, functional requirements, non-functional requirements, traceability matrix, acceptance criteria
**🏗️ System Architecture**: `system_architecture.md` | **Phase 2** | System overview, data flow, security architecture, scalability patterns, component interactions, folder structure, technical specifications, deployment architecture, database schema, API contracts, ERD
**🏗️ Phase 2 Design & Architecture**: `phase_2_design_architecture.md` | **Phase 2** | Frontend architecture, backend architecture, integration architecture, database architecture with code roadmaps (Frontend code roadmap, Backend code roadmap, Integration code roadmap, Database code roadmap)
**👤 User Journey Flow**: `user_journey_flow.md` | **Phase 2A** | User journey flow with Mermaid diagram (user entry points, main flows, alternative flows, decision points, success/failure paths, error handling)
**⚡ Phase 3 Implementation & Development**: `phase_3_implementation_development.md` | **Phase 3** | TDD methodology with RED-GREEN-REFACTOR cycle (Frontend unit tests, Backend unit tests, Database unit tests, Integration tests)
**🧪 Phase 4 E2E Testing and Comprehensive QA**: `phase_4_e2e_testing_qa.md` | **Phase 4** | E2E testing, user journey testing, performance testing, security testing, code review, quality validation, test coverage analysis
**🚀 Phase 5 Deployment & Release**: `phase_5_deployment_release.md` | **Phase 5** | Deployment configurations, production setup, release management, production deployment
**🔒 Phase 6 Cybersecurity**: `phase_6_cybersecurity.md` | **Phase 6** | Security validation, penetration testing, security implementation, compliance verification

**📋 Technical Documentation**: All technical documentation consolidated within respective phase documents for development efficiency

### **🎯 ACTUAL FILE GENERATION SYSTEM**

**Generate Real Working Files**: Each phase produces actual, implementable project files that Cursor AI can immediately use:
- **Source Code Files**: UI components, API routes, database models, middleware, authentication logic
- **Test Files**: Component tests, unit tests, integration tests, e2e tests, security tests, performance tests
- **Configuration Files**: package.json, tsconfig.json, Dockerfile, .env templates, docker-compose.yml
- **Database Files**: Migration scripts, seed data, schema files, query implementations
- **Deployment Files**: CI/CD pipelines, deployment configurations, infrastructure setup
- **User Journey Files**: user_journey_flow.md with Mermaid diagram for E2E testing
- **Requirements Files**: requirements_specification.md with comprehensive requirements documentation
- **Architecture Files**: system_architecture.md with system overview, data flow, security architecture, scalability patterns, folder structure, technical specifications, deployment architecture, database schema, API contracts, ERD

### **📦 COMPLETE DELIVERABLE PACKAGE**

**Final Artifacts Delivered**:
- **Working Application**: Deployed, accessible, fully functional fullstack application
- **Complete Source Code**: Frontend, backend, database with 85%+ test coverage
- **Comprehensive Test Suite**: Unit tests, integration tests, E2E tests, security tests, performance tests
- **Production Deployment**: CI/CD pipelines, infrastructure as code
- **Technical Documentation**: Phase documents, API documentation, deployment guides, architecture documentation
- **Security Validation**: Security assessment, penetration testing, compliance verification
- **Quality Assurance**: Code review reports, performance optimization, test coverage analysis
- **User Journey Documentation**: Complete user flow with Mermaid diagrams for testing scenarios

**TDD-QA-CodeReview Loop**: Phase 3A Frontend unit tests (RED-GREEN-REFACTOR), Phase 3B Backend unit tests (RED-GREEN-REFACTOR), Phase 3B.5 Database unit tests (RED-GREEN-REFACTOR), Phase 3C Integration tests (RED-GREEN-REFACTOR), Phase 4 E2E testing and comprehensive QA (user journey testing, performance testing, security testing, code review, quality validation).

**Embedded TDD Methodology**: Each phase generates complete working features with comprehensive tests embedded, following TDD principles within the phase for optimal Cursor AI execution.

**Validation**: Project roadmap criteria (ACTIVELY TRACKED AND UPDATED)

---

## ⚠️ **IMPORTANT**

Do NOT skip validation criteria | Do NOT proceed without completing phase | Do enforce TDD-QA-CodeReview loop | Do generate actual working files | Do validate after each implementation | Do use multi-role mediated debate for decisions | Do adapt to tech stack | **Do ACTIVELY TRACK roadmap progress** | **Do REFUSE to proceed without 100% roadmap completion** | **Do EMBED security throughout all phases** | **Do GENERATE complete working features** | **Do OPTIMIZE for efficiency** | **Do follow subphase structure with user confirmation between subphases** | **Do assign relevant roles to each subphase** | **Do enforce RED-GREEN-REFACTOR cycle** | **Do use 15 rounds until consensus for mediated debates** | **Do PROVIDE comprehensive guidance for Cursor AI**

---

**Start now. Begin Phase 1. Begin building a production-ready application!**

---

*Framework ensuring working applications through systematic development, TDD-QA-CodeReview loop, multi-role mediated debate (15 rounds until consensus), actual file generation, validation, mediated decision-making, comprehensive cybersecurity implementation, streamlined active roadmap tracking with hard validation for guaranteed project completion, and developer-focused delivery*
